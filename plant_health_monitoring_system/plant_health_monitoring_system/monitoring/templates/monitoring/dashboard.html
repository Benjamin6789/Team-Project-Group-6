<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plant Health Monitoring Dashboard</title>

    <!-- Link to Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Link to Font Awesome for plant icon -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f7fa;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .header-right {
            margin-right: 20px;
        }
        h1 {
            margin: 0;
            font-size: 36px;
        }
        .container {
            width: 80%;
            margin: 30px auto;
        }
        table {
            width: 100%;
            margin-top: 20px;
            border-collapse: collapse;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: center;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        td {
            background-color: #f9f9f9;
        }
        .charts-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 40px;
        }
        .chart-container {
            width: calc(33% - 15px);
            min-width: 300px;
            flex-grow: 1;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        canvas {
            width: 100% !important;
            margin: 0 auto;
        }
        .footer {
            text-align: center;
            padding: 20px;
            background-color: #4CAF50;
            color: white;
        }
        .status-indicator {
            display: inline-block;
            height: 10px;
            width: 10px;
            border-radius: 50%;
            margin-left: 10px;
        }
        .status-online {
            background-color: #4CAF50;
        }
        .status-offline {
            background-color: #f44336;
        }
        .refresh-control {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .btn {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .btn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .btn-start {
            background-color: #2196F3;
        }
        
        .btn-start:hover {
            background-color: #0b7dda;
        }
        
        .btn-stop {
            background-color: #f44336;
        }
        
        .btn-stop:hover {
            background-color: #d32f2f;
        }
        
        .collapsible {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            padding: 18px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 18px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        
        .active, .collapsible:hover {
            background-color: #45a049;
        }
        
        .collapsible:after {
            content: '\002B';
            font-weight: bold;
            float: right;
            margin-left: 5px;
        }
        
        .active:after {
            content: "\2212";
        }
        
        .content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
            background-color: white;
            border-radius: 0 0 8px 8px;
            border: 1px solid #ddd;
            border-top: none;
        }

        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            padding: 20px;
        }

        .data-card {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
        }

        .data-card h3 {
            margin-top: 0;
            color: #333;
        }

        .data-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }

        .settings-container {
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            margin: 15px;
        }
        
        .time-range-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin: 15px 20px;
            gap: 10px;
        }
        
        .btn-group {
            display: flex;
        }
        
        .btn-time-range {
            background-color: #e0e0e0;
            color: #333;
            border: 1px solid #ccc;
            padding: 8px 12px;
            transition: all 0.2s ease;
        }
        
        .btn-time-range:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .btn-time-range:last-child {
            border-radius: 0 4px 4px 0;
        }
        
        .btn-time-range.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .btn-time-range:hover:not(.active) {
            background-color: #d0d0d0;
        }

        #interval-status {
            margin-top: 10px;
            font-weight: bold;
            min-height: 20px;
        }

        @media (max-width: 900px) {
            .chart-container {
                width: 100%;
            }
            .overview-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .btn-chart-toggle {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 12px;
            margin: 0;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .btn-chart-toggle:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Alert styles */
        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            border-left: 5px solid;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .alert-warning {
            background-color: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }
        
        .alert-info {
            background-color: #d1ecf1;
            border-left-color: #17a2b8;
            color: #0c5460;
        }
        
        .alert-danger {
            background-color: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }
        
        .alert-success {
            background-color: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }
        
        .alert-icon {
            margin-right: 10px;
            font-size: 20px;
        }
        
        .alert-hidden {
            display: none;
        }
        
        .alert-close {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 20px;
            color: inherit;
            opacity: 0.7;
        }
        
        .alert-close:hover {
            opacity: 1;
        }

        .admin-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            font-weight: bold;
            text-decoration: none;
            transition: all 0.3s ease;
            display: inline-block;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .admin-btn:hover {
            background-color: #0b7dda;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            header {
                flex-direction: column;
                padding: 15px;
                gap: 10px;
            }
            .header-right {
                margin-right: 0;
                margin-top: 10px;
            }
            .admin-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>

<header>
    <div class="header-left">
        <!-- Plant Symbol/Icon -->
        <i class="fas fa-seedling" style="font-size: 40px;"></i>
        <h1>Plant Health Monitoring Dashboard</h1>
    </div>
    <div class="header-right">
        {% if request.user.is_authenticated and request.user.is_staff %}
            <a href="/admin" class="admin-btn">Admin Panel</a>
        {% else %}
            <a href="/admin/login/?next=/dashboard/" class="admin-btn">Login</a>
        {% endif %}
    </div>
</header>

<div class="container">
    <!-- System status alert box - hidden by default, will be shown when there's an issue -->
    <div id="statusAlert" class="alert alert-warning alert-hidden">
        <div>
            <i class="fas fa-exclamation-triangle alert-icon"></i>
            <span id="statusMessage">System status information will appear here.</span>
        </div>
        <button class="alert-close" onclick="closeAlert()">&times;</button>
    </div>

    <!-- Real-time status and controls -->
    <div class="refresh-control">
        <div>
            <h2>Live Monitoring 
                <span id="connection-status" class="status-indicator status-offline" title="Offline"></span>
                <span id="status-text">Offline</span>
            </h2>
        </div>
        <div>
            <button id="toggle-refresh" class="btn btn-start">Show Updates</button>
            <button id="set-interval" class="btn" style="background-color: #4CAF50; margin-left: 10px;">Set Collection Interval</button>
            <button id="set-graph-interval" class="btn" style="background-color: #2196F3; margin-left: 10px;">Set Graph Refresh</button>
        </div>
        <div style="margin-top: 10px; padding: 10px; background-color: #f1f1f1; border-radius: 4px;">
            <h4 style="margin: 0 0 5px 0;">System Intervals</h4>
            <div style="display: flex; gap: 20px;">
                <div>
                    <span style="font-weight: bold;">Data Collection:</span> 
                    <span id="collection-interval">5 seconds</span>
                </div>
                <div>
                    <span style="font-weight: bold;">Graph Refresh:</span> 
                    <span id="graph-refresh-interval">5 seconds</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Current Reading Overview -->
    <button class="collapsible">Current Plant Readings</button>
    <div class="content">
        <div class="overview-grid" id="current-readings">
            <div class="data-card">
                <h3>Temperature</h3>
                <div class="data-value" id="current-temperature">--</div>
                <div>째C</div>
            </div>
            <div class="data-card">
                <h3>Humidity</h3>
                <div class="data-value" id="current-humidity">--</div>
                <div>%</div>
            </div>
            <div class="data-card">
                <h3>Soil Moisture</h3>
                <div class="data-value" id="current-soil-moisture">--</div>
                <div>%</div>
            </div>
            <div class="data-card">
                <h3>Air Quality</h3>
                <div class="data-value" id="current-air-quality">--</div>
                <div>index</div>
            </div>
            <div class="data-card">
                <h3>Light</h3>
                <div class="data-value" id="current-light">--</div>
                <div>index</div>
            </div>
            <div class="data-card">
                <h3>Pressure</h3>
                <div class="data-value" id="current-pressure">--</div>
                <div>index</div>
            </div>
            <div class="data-card">
                <h3>Oxidising</h3>
                <div class="data-value" id="current-oxidising">--</div>
                <div>index</div>
            </div>
            <div class="data-card">
                <h3>Reducing</h3>
                <div class="data-value" id="current-reducing">--</div>
                <div>index</div>
            </div>
        </div>
    </div>

    <!-- Historical Data Table -->
    <button class="collapsible">Historical Data</button>
    <div class="content">
    <!-- Table showing the plant data -->
    <h2>Latest Plant Data</h2>
    <table id="data-table">
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Temperature (째C)</th>
                <th>Humidity (%)</th>
                <th>Soil Moisture (%)</th>
                <th>Air Quality</th>
                <th>Light</th>
                <th>Pressure</th>
                <th>Oxidising</th>
                <th>Reducing</th>
            </tr>
        </thead>
        <tbody>
            {% for data in plant_data %}
            <tr>
                <td>{{ data.timestamp }}</td>
                <td>{{ data.temperature }}</td>
                <td>{{ data.humidity }}</td>
                <td>{{ data.soil_moisture }}</td>
                <td>{{ data.air_quality }}</td>
                <td>{% if data.light != None %}{{ data.light }}{% else %}-{% endif %}</td>
                <td>{% if data.pressure != None %}{{ data.pressure }}{% else %}-{% endif %}</td>
                <td>{% if data.oxidising != None %}{{ data.oxidising }}{% else %}-{% endif %}</td>
                <td>{% if data.reducing != None %}{{ data.reducing }}{% else %}-{% endif %}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    </div>

    <!-- Charts Grid Container -->
    <button class="collapsible active">Charts</button>
    <div class="content" style="max-height: 2000px;">
    <div class="time-range-controls">
        <span>Time Range: </span>
        <div class="btn-group">
            <button class="btn btn-time-range active" data-range="60s">Last 60s</button>
            <button class="btn btn-time-range" data-range="1h">Last Hour</button>
            <button class="btn btn-time-range" data-range="24h">Last 24h</button>
        </div>
    </div>
    <div class="charts-grid">
        <!-- Chart Container for Temperature -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Temperature (째C) Over Time</h3>
                <button class="btn btn-chart-toggle" data-chart="temperature">Pause</button>
            </div>
            <canvas id="temperatureChart"></canvas>
        </div>

        <!-- Chart Container for Humidity -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Humidity (%) Over Time</h3>
                <button class="btn btn-chart-toggle" data-chart="humidity">Pause</button>
            </div>
            <canvas id="humidityChart"></canvas>
        </div>

        <!-- Chart Container for Soil Moisture -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Soil Moisture (%) Over Time</h3>
                <button class="btn btn-chart-toggle" data-chart="soilMoisture">Pause</button>
            </div>
            <canvas id="soilMoistureChart"></canvas>
        </div>

        <!-- Chart Container for Air Quality -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Air Quality Over Time</h3>
                <button class="btn btn-chart-toggle" data-chart="airQuality">Pause</button>
            </div>
            <canvas id="airQualityChart"></canvas>
        </div>
    </div>
    </div>

    <!-- Additional Sensor Charts -->
    <button class="collapsible">Additional Sensor Charts</button>
    <div class="content">
    <div class="charts-grid">
        <!-- Chart Container for Light -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Light Level Over Time</h3>
                <button class="btn btn-chart-toggle paused" data-chart="light">Resume</button>
            </div>
            <canvas id="lightChart"></canvas>
        </div>

        <!-- Chart Container for Pressure -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Pressure Over Time</h3>
                <button class="btn btn-chart-toggle paused" data-chart="pressure">Resume</button>
            </div>
            <canvas id="pressureChart"></canvas>
        </div>

        <!-- Chart Container for Oxidising -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Oxidising Gases Over Time</h3>
                <button class="btn btn-chart-toggle paused" data-chart="oxidising">Resume</button>
            </div>
            <canvas id="oxidisingChart"></canvas>
        </div>

        <!-- Chart Container for Reducing -->
        <div class="chart-container">
            <div class="chart-header">
                <h3>Reducing Gases Over Time</h3>
                <button class="btn btn-chart-toggle paused" data-chart="reducing">Resume</button>
            </div>
            <canvas id="reducingChart"></canvas>
        </div>
    </div>
    </div>
</div>

<!-- Footer Section -->
<div class="footer">
    <p>&copy; 2025 Plant Health Monitoring System</p>
</div>

<!-- Script to render the Charts -->
<script>
    // Flag to check if auto-start is enabled from server
    const autoStartEnabled = {% if auto_start %}true{% else %}false{% endif %};
    
    // Add helper function to format timestamps to local timezone
    function formatTimestamp(isoString) {
        const date = new Date(isoString);
        return date.toLocaleTimeString();
    }
    
    // Initialize chart data
    // Note: These arrays are created from Django template tags and should be in reverse chronological order
    // (newest data first, as that's how Django's order_by('-timestamp') returns it)
    // We need to reverse them to ensure they're in chronological order (oldest first)
    const initialLabels = [{% for data in plant_data %}'{{ data.timestamp }}',{% endfor %}];
    const initialTemperatureData = [{% for data in plant_data %}{{ data.temperature }},{% endfor %}];
    const initialHumidityData = [{% for data in plant_data %}{{ data.humidity }},{% endfor %}];
    const initialSoilMoistureData = [{% for data in plant_data %}{{ data.soil_moisture }},{% endfor %}];
    const initialAirQualityData = [{% for data in plant_data %}{{ data.air_quality }},{% endfor %}];
    
    // Initial data arrays for the additional sensors
    const initialLightData = [{% for data in plant_data %}{{ data.light }},{% endfor %}];
    const initialPressureData = [{% for data in plant_data %}{{ data.pressure }},{% endfor %}];
    const initialOxidisingData = [{% for data in plant_data %}{{ data.oxidising }},{% endfor %}];
    const initialReducingData = [{% for data in plant_data %}{{ data.reducing }},{% endfor %}];
    
    // Reverse all arrays to get chronological order (oldest first)
    initialLabels.reverse();
    // Convert initial labels to local timezone
    const formattedLabels = initialLabels.map(label => formatTimestamp(label));
    initialTemperatureData.reverse();
    initialHumidityData.reverse();
    initialSoilMoistureData.reverse();
    initialAirQualityData.reverse();
    initialLightData.reverse();
    initialPressureData.reverse();
    initialOxidisingData.reverse();
    initialReducingData.reverse();

    // Create chart objects
    const temperatureChart = createChart('temperatureChart', 'Temperature (째C)', formattedLabels, initialTemperatureData, '#FF5733');
    const humidityChart = createChart('humidityChart', 'Humidity (%)', formattedLabels, initialHumidityData, '#33B5FF');
    const soilMoistureChart = createChart('soilMoistureChart', 'Soil Moisture (%)', formattedLabels, initialSoilMoistureData, '#4CAF50');
    const airQualityChart = createChart('airQualityChart', 'Air Quality', formattedLabels, initialAirQualityData, '#FFC107');
    
    // Create additional chart objects
    const lightChart = createChart('lightChart', 'Light Level', formattedLabels, initialLightData, '#9C27B0');
    const pressureChart = createChart('pressureChart', 'Pressure', formattedLabels, initialPressureData, '#795548');
    const oxidisingChart = createChart('oxidisingChart', 'Oxidising Gases', formattedLabels, initialOxidisingData, '#F44336');
    const reducingChart = createChart('reducingChart', 'Reducing Gases', formattedLabels, initialReducingData, '#3F51B5');

    // Function to create a chart
    function createChart(elementId, label, labels, data, borderColor) {
        const ctx = document.getElementById(elementId).getContext('2d');
        return new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    borderColor: borderColor,
                    backgroundColor: borderColor.replace(')', ', 0.2)').replace('rgb', 'rgba'),
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        ticks: {
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 8
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: label
                        }
                    }
                }
            }
        });
    }

    // Auto-start when the page has fully loaded
    window.onload = function() {
        // Auto-start if configured to do so
        if (autoStartEnabled && !isRefreshing) {
            console.log("Auto-starting real-time updates...");
            toggleRefresh(); // This will set isRefreshing to true and update UI
        } else if (!autoStartEnabled) {
            // Ensure UI is correct if not auto-starting
            const toggleButton = document.getElementById('toggle-refresh');
            const statusIndicator = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            
            toggleButton.textContent = 'Show Updates';
            toggleButton.classList.remove('btn-stop');
            toggleButton.classList.add('btn-start');
            statusIndicator.classList.remove('status-online');
            statusIndicator.classList.add('status-offline');
            statusText.textContent = 'Offline';
            isRefreshing = false;
        }
        
        // Set initial values for interval displays
        document.getElementById('collection-interval').textContent = "5 seconds";
        document.getElementById('graph-refresh-interval').textContent = "5 seconds";
        
        // Set up time range buttons
        setupTimeRangeButtons();
        
        // Set up chart toggle buttons
        setupChartToggleButtons();
        
        // Start system status monitoring
        startSystemStatusMonitoring();
    };

    // Function to set up time range buttons
    function setupTimeRangeButtons() {
        const timeRangeButtons = document.querySelectorAll('.btn-time-range');
        
        timeRangeButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Don't do anything if this button is already active
                if (this.classList.contains('active')) return;
                
                // Remove active class from all buttons
                timeRangeButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to the clicked button
                this.classList.add('active');
                
                // Update the current time range
                const newTimeRange = this.getAttribute('data-range');
                console.log(`Changing time range from ${currentTimeRange} to ${newTimeRange}`);
                currentTimeRange = newTimeRange;
                
                // Fetch data for the new time range immediately
                fetchLatestData();
            });
        });
    }

    // Function to set up chart toggle buttons
    function setupChartToggleButtons() {
        const chartToggleButtons = document.querySelectorAll('.btn-chart-toggle');
        
        chartToggleButtons.forEach(button => {
            button.addEventListener('click', function() {
                const chartName = this.getAttribute('data-chart');
                
                // Toggle the paused state
                chartStates[chartName].paused = !chartStates[chartName].paused;
                
                // Update button text
                this.textContent = chartStates[chartName].paused ? 'Resume' : 'Pause';
                
                // Update button appearance
                if (chartStates[chartName].paused) {
                    this.style.backgroundColor = '#f44336'; // Red for paused
                } else {
                    this.style.backgroundColor = '#4CAF50'; // Green for active
                }
                
                console.log(`Chart ${chartName} is now ${chartStates[chartName].paused ? 'paused' : 'resuming'}`);
            });
        });
    }

    // Real-time update functionality
    let refreshIntervalId = null;
    let refreshInterval = 5000; // 5 seconds (default)
    const maxDataPoints = 20; // Maximum number of data points to display
    let isRefreshing = false;
    let currentTimeRange = '60s'; // Default time range
    
    // Track which charts are paused
    const chartStates = {
        temperature: { paused: false },
        humidity: { paused: false },
        soilMoisture: { paused: false },
        airQuality: { paused: false },
        light: { paused: true },
        pressure: { paused: true },
        oxidising: { paused: true },
        reducing: { paused: true }
    };

    // Function to toggle real-time updates
    function toggleRefresh() {
        const toggleButton = document.getElementById('toggle-refresh');
        const statusIndicator = document.getElementById('connection-status');
        const statusText = document.getElementById('status-text');

        if (isRefreshing) {
            // ---> STOPPING <---
            clearInterval(refreshIntervalId);
            refreshIntervalId = null; // Ensure ID is cleared
            isRefreshing = false; // Update state FIRST
            
            // Update UI
            toggleButton.textContent = 'Show Updates';
            toggleButton.classList.remove('btn-stop');
            toggleButton.classList.add('btn-start');
            statusIndicator.classList.remove('status-online');
            statusIndicator.classList.add('status-offline');
            statusText.textContent = 'Offline';
            console.log("Real-time updates stopped.");

        } else {
            // ---> STARTING <--- 
            if (refreshIntervalId !== null) {
                // Safety check: Clear any existing interval before starting a new one
                clearInterval(refreshIntervalId);
            }
            isRefreshing = true; // Update state FIRST
            
            // Update UI
            toggleButton.textContent = 'Stop Updates';
            toggleButton.classList.remove('btn-start');
            toggleButton.classList.add('btn-stop');
            statusIndicator.classList.remove('status-offline');
            statusIndicator.classList.add('status-online');
            statusText.textContent = 'Online';
            
            // Fetch data immediately and start interval
            console.log("Starting real-time updates with interval of " + (refreshInterval/1000) + " seconds");
            fetchLatestData();
            refreshIntervalId = setInterval(fetchLatestData, refreshInterval);
        }
    }

    // Function to fetch the latest data
    function fetchLatestData() {
        // Ensure we only fetch if refreshing is supposed to be active
        if (!isRefreshing) {
            console.log("Fetch skipped because isRefreshing is false.");
            return; 
        }
        console.log(`Fetching data for time range: ${currentTimeRange}...`);
        
        // Use the appropriate endpoint based on whether we're showing real-time or historical data
        const endpoint = (currentTimeRange === '60s') 
            ? '/api/latest-data/' 
            : `/api/data-by-range/?range=${currentTimeRange}`;
            
        fetch(endpoint)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                // Update connection status to online if successful
                const statusIndicator = document.getElementById('connection-status');
                const statusText = document.getElementById('status-text');
                // Only update status if we are still in 'refreshing' mode
                if (isRefreshing) {
                    statusIndicator.classList.remove('status-offline');
                    statusIndicator.classList.add('status-online');
                    statusText.textContent = 'Online';
                }
                
                return response.json();
            })
            .then(data => {
                if (data && data.length > 0 && isRefreshing) {
                    // Get the most recent data point (first in the array)
                    const latestData = data[0];
                    updateCharts(latestData);
                    updateTable(latestData);
                    
                    // Update the current readings overview
                    updateCurrentReadings(latestData);
                    
                    // Update all data points in the charts if needed
                    updateAllCharts(data.reverse());
                }
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                // Only update status if we are still supposed to be refreshing
                if (isRefreshing) {
                    // Update connection status to offline if there's an error
                    const statusIndicator = document.getElementById('connection-status');
                    const statusText = document.getElementById('status-text');
                    statusIndicator.classList.remove('status-online');
                    statusIndicator.classList.add('status-offline');
                    statusText.textContent = 'Offline - Retrying...';
                }
                
                // Don't stop the auto-refresh, just let it try again
            });
    }

    // Function to update the current readings
    function updateCurrentReadings(data) {
        if (!isRefreshing) return; // Don't update if stopped
        document.getElementById('current-temperature').textContent = data.temperature.toFixed(1);
        document.getElementById('current-humidity').textContent = data.humidity.toFixed(1);
        document.getElementById('current-soil-moisture').textContent = data.soil_moisture.toFixed(1);
        document.getElementById('current-air-quality').textContent = data.air_quality.toFixed(1);
        document.getElementById('current-light').textContent = data.light.toFixed(1);
        document.getElementById('current-pressure').textContent = data.pressure.toFixed(1);
        document.getElementById('current-oxidising').textContent = data.oxidising.toFixed(1);
        document.getElementById('current-reducing').textContent = data.reducing.toFixed(1);
    }

    // Function to update the charts
    function updateCharts(data) {
        if (!isRefreshing) return; // Don't update if stopped
        // Get current timestamp (or use the one from the data)
        const timestamp = data.timestamp;

        // Update temperature chart if not paused
        if (!chartStates.temperature.paused) {
            updateChart(temperatureChart, timestamp, data.temperature);
        }
        
        // Update humidity chart if not paused
        if (!chartStates.humidity.paused) {
            updateChart(humidityChart, timestamp, data.humidity);
        }
        
        // Update soil moisture chart if not paused
        if (!chartStates.soilMoisture.paused) {
            updateChart(soilMoistureChart, timestamp, data.soil_moisture);
        }
        
        // Update air quality chart if not paused
        if (!chartStates.airQuality.paused) {
            updateChart(airQualityChart, timestamp, data.air_quality);
        }
        
        // Update light chart if not paused
        if (!chartStates.light.paused) {
            updateChart(lightChart, timestamp, data.light);
        }
        
        // Update pressure chart if not paused
        if (!chartStates.pressure.paused) {
            updateChart(pressureChart, timestamp, data.pressure);
        }
        
        // Update oxidising chart if not paused
        if (!chartStates.oxidising.paused) {
            updateChart(oxidisingChart, timestamp, data.oxidising);
        }
        
        // Update reducing chart if not paused
        if (!chartStates.reducing.paused) {
            updateChart(reducingChart, timestamp, data.reducing);
        }
    }

    // Function to update a single chart
    function updateChart(chart, label, value) {
        if (!isRefreshing) return; // Don't update if stopped
        
        // Format timestamp to local time
        const formattedLabel = formatTimestamp(label);
        
        // Add new data point (to end of arrays - for newest data)
        chart.data.labels.push(formattedLabel);
        chart.data.datasets[0].data.push(value);
        
        // Remove oldest data point if we exceed maxDataPoints
        if (chart.data.labels.length > maxDataPoints) {
            chart.data.labels.shift();
            chart.data.datasets[0].data.shift();
        }
        
        // Update the chart
        chart.update();
    }

    // Function to update the table
    function updateTable(data) {
        if (!isRefreshing) return; // Don't update if stopped
        const tableBody = document.querySelector('#data-table tbody');
        
        // Create a new row
        const newRow = document.createElement('tr');
        
        // Format timestamp to local time
        const formattedTimestamp = formatTimestamp(data.timestamp);
        
        // Add cells with data
        newRow.innerHTML = `
            <td>${formattedTimestamp}</td>
            <td>${data.temperature}</td>
            <td>${data.humidity}</td>
            <td>${data.soil_moisture}</td>
            <td>${data.air_quality}</td>
            <td>${data.light || '-'}</td>
            <td>${data.pressure || '-'}</td>
            <td>${data.oxidising || '-'}</td>
            <td>${data.reducing || '-'}</td>
        `;
        
        // Add the new row at the top of the table
        tableBody.insertBefore(newRow, tableBody.firstChild);
        
        // Remove the last row if there are too many
        if (tableBody.children.length > maxDataPoints) {
            tableBody.removeChild(tableBody.lastChild);
        }
    }

    // Function to update all charts with multiple data points
    function updateAllCharts(dataArray) {
        if (!isRefreshing) return; // Don't update if stopped
        
        // Note: dataArray should already be in chronological order (oldest first) from the server
        
        // Clear and update temperature chart if not paused
        if (!chartStates.temperature.paused) {
            temperatureChart.data.labels = [];
            temperatureChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                temperatureChart.data.labels.push(formattedTimestamp);
                temperatureChart.data.datasets[0].data.push(point.temperature);
            });
            
            // Update the chart
            temperatureChart.update();
        }
        
        // Clear and update humidity chart if not paused
        if (!chartStates.humidity.paused) {
            humidityChart.data.labels = [];
            humidityChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                humidityChart.data.labels.push(formattedTimestamp);
                humidityChart.data.datasets[0].data.push(point.humidity);
            });
            
            // Update the chart
            humidityChart.update();
        }
        
        // Clear and update soil moisture chart if not paused
        if (!chartStates.soilMoisture.paused) {
            soilMoistureChart.data.labels = [];
            soilMoistureChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                soilMoistureChart.data.labels.push(formattedTimestamp);
                soilMoistureChart.data.datasets[0].data.push(point.soil_moisture);
            });
            
            // Update the chart
            soilMoistureChart.update();
        }
        
        // Clear and update air quality chart if not paused
        if (!chartStates.airQuality.paused) {
            airQualityChart.data.labels = [];
            airQualityChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                airQualityChart.data.labels.push(formattedTimestamp);
                airQualityChart.data.datasets[0].data.push(point.air_quality);
            });
            
            // Update the chart
            airQualityChart.update();
        }
        
        // Clear and update light chart if not paused
        if (!chartStates.light.paused) {
            lightChart.data.labels = [];
            lightChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                lightChart.data.labels.push(formattedTimestamp);
                lightChart.data.datasets[0].data.push(point.light);
            });
            
            // Update the chart
            lightChart.update();
        }
        
        // Clear and update pressure chart if not paused
        if (!chartStates.pressure.paused) {
            pressureChart.data.labels = [];
            pressureChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                pressureChart.data.labels.push(formattedTimestamp);
                pressureChart.data.datasets[0].data.push(point.pressure);
            });
            
            // Update the chart
            pressureChart.update();
        }
        
        // Clear and update oxidising chart if not paused
        if (!chartStates.oxidising.paused) {
            oxidisingChart.data.labels = [];
            oxidisingChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                oxidisingChart.data.labels.push(formattedTimestamp);
                oxidisingChart.data.datasets[0].data.push(point.oxidising);
            });
            
            // Update the chart
            oxidisingChart.update();
        }
        
        // Clear and update reducing chart if not paused
        if (!chartStates.reducing.paused) {
            reducingChart.data.labels = [];
            reducingChart.data.datasets[0].data = [];
            
            // Add data points in order
            dataArray.forEach(point => {
                // Format timestamp to local time
                const formattedTimestamp = formatTimestamp(point.timestamp);
                reducingChart.data.labels.push(formattedTimestamp);
                reducingChart.data.datasets[0].data.push(point.reducing);
            });
            
            // Update the chart
            reducingChart.update();
        }
    }

    // Set up collapsible sections
    const coll = document.getElementsByClassName("collapsible");
    
    for (let i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            const content = this.nextElementSibling;
            
            if (content.style.maxHeight) {
                content.style.maxHeight = null;
            } else {
                content.style.maxHeight = content.scrollHeight + "px";
            }
        });
    }
    
    // Initialize the current readings if we have data
    if (initialTemperatureData.length > 0) {
        updateCurrentReadings({
            temperature: initialTemperatureData[initialTemperatureData.length-1],
            humidity: initialHumidityData[initialHumidityData.length-1],
            soil_moisture: initialSoilMoistureData[initialSoilMoistureData.length-1],
            air_quality: initialAirQualityData[initialAirQualityData.length-1],
            light: initialLightData[initialLightData.length-1],
            pressure: initialPressureData[initialPressureData.length-1],
            oxidising: initialOxidisingData[initialOxidisingData.length-1],
            reducing: initialReducingData[initialReducingData.length-1]
        });
    }

    // Add event listener to the toggle button with debounce to prevent rapid clicking
    let toggleBusy = false;
    document.getElementById('toggle-refresh').addEventListener('click', function() {
        if (toggleBusy) return;
        
        toggleBusy = true;
        toggleRefresh();
        
        // Prevent multiple clicks for 1 second
        setTimeout(() => {
            toggleBusy = false;
        }, 1000);
    });
    
    // System status monitoring functions
    let systemStatusTimer = null;
    
    function startSystemStatusMonitoring() {
        // Check system status immediately
        checkSystemStatus();
        
        // Then check periodically (every 5 seconds)
        systemStatusTimer = setInterval(checkSystemStatus, 5000);
    }
    
    function stopSystemStatusMonitoring() {
        if (systemStatusTimer) {
            clearInterval(systemStatusTimer);
            systemStatusTimer = null;
        }
    }
    
    function checkSystemStatus() {
        fetch('/api/system-status/')
            .then(response => response.json())
            .then(data => {
                updateSystemStatusDisplay(data);
            })
            .catch(error => {
                console.error('Error fetching system status:', error);
            });
    }
    
    function updateSystemStatusDisplay(statusData) {
        const alertBox = document.getElementById('statusAlert');
        const messageElement = document.getElementById('statusMessage');
        
        if (statusData.is_collecting_delayed) {
            // Show warning with message from server
            alertBox.className = 'alert alert-warning';
            messageElement.textContent = statusData.status_message;
        } else {
            // No issues, hide the alert
            alertBox.className = 'alert alert-warning alert-hidden';
        }
    }
    
    function closeAlert() {
        document.getElementById('statusAlert').className = 'alert alert-warning alert-hidden';
    }
    
    // Ensure we clean up when the page is closed
    window.addEventListener('beforeunload', function() {
        if (refreshIntervalId) {
            clearInterval(refreshIntervalId);
        }
        stopSystemStatusMonitoring();
    });
    
    // Add modal for interval adjustment functionality
    document.addEventListener('DOMContentLoaded', function() {
        const intervalModal = document.getElementById('interval-modal');
        const intervalInput = document.getElementById('interval-input');
        const intervalValue = document.getElementById('interval-value');
        const intervalStatus = document.getElementById('interval-status');
        
        // Update displayed value when slider moves
        if (intervalInput) {
            intervalInput.addEventListener('input', function() {
                intervalValue.textContent = this.value;
            });
        }
        
        // Open modal when Set Interval button is clicked
        const setIntervalBtn = document.getElementById('set-interval');
        if (setIntervalBtn) {
            setIntervalBtn.addEventListener('click', function() {
                console.log('Set Interval button clicked');
                // Set initial value based on current interval
                const currentIntervalText = document.getElementById('collection-interval').textContent;
                const match = currentIntervalText.match(/\d+(\.\d+)?/);
                if (match) {
                    const currentValue = parseFloat(match[0]);
                    intervalInput.value = currentValue;
                    intervalValue.textContent = currentValue;
                }
                // Show the modal
                intervalModal.style.display = 'block';
            });
        }
        
        // Close modal when Cancel is clicked
        const cancelBtn = document.getElementById('cancel-interval');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', function() {
                intervalModal.style.display = 'none';
                intervalStatus.textContent = '';
            });
        }
        
        // Close modal when X is clicked
        const closeBtn = document.getElementById('close-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', function() {
                intervalModal.style.display = 'none';
                intervalStatus.textContent = '';
            });
        }
    });
    
    // Set up modal for graph refresh interval
    document.addEventListener('DOMContentLoaded', function() {
        const graphIntervalModal = document.getElementById('graph-interval-modal');
        const graphIntervalInput = document.getElementById('graph-interval-input');
        const graphIntervalValue = document.getElementById('graph-interval-value');
        const graphIntervalStatus = document.getElementById('graph-interval-status');
        
        // Update displayed value when slider moves
        if (graphIntervalInput) {
            graphIntervalInput.addEventListener('input', function() {
                graphIntervalValue.textContent = this.value;
            });
        }
        
        // Open modal when Set Graph Refresh button is clicked
        const setGraphIntervalBtn = document.getElementById('set-graph-interval');
        if (setGraphIntervalBtn) {
            setGraphIntervalBtn.addEventListener('click', function() {
                console.log('Set Graph Refresh button clicked');
                // Set initial value based on current interval
                const currentIntervalText = document.getElementById('graph-refresh-interval').textContent;
                const match = currentIntervalText.match(/\d+(\.\d+)?/);
                if (match) {
                    const currentValue = parseFloat(match[0]);
                    graphIntervalInput.value = currentValue;
                    graphIntervalValue.textContent = currentValue;
                }
                // Show the modal
                graphIntervalModal.style.display = 'block';
            });
        }
        
        // Close modal when X is clicked
        const closeGraphModalBtn = document.getElementById('close-graph-modal');
        if (closeGraphModalBtn) {
            closeGraphModalBtn.addEventListener('click', function() {
                graphIntervalModal.style.display = 'none';
                graphIntervalStatus.textContent = '';
            });
        }
    });
    
    // Function to change the graph refresh interval (in seconds)
    function updateGraphRefreshInterval(seconds) {
        // Convert to milliseconds
        refreshInterval = seconds * 1000;
        
        // If we're currently refreshing, restart the interval with the new timing
        if (isRefreshing && refreshIntervalId !== null) {
            clearInterval(refreshIntervalId);
            refreshIntervalId = setInterval(fetchLatestData, refreshInterval);
            console.log(`Graph refresh interval updated to ${seconds} seconds`);
        }
        
        // Update the display text for the graph refresh interval element
        document.getElementById('graph-refresh-interval').textContent = `${seconds} seconds`;
    }
</script>

<!-- Add modal for interval adjustment -->
<div id="interval-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4);">
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; width: 400px; max-width: 90%; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
        <span id="close-modal" style="position: absolute; top: 10px; right: 15px; font-size: 20px; cursor: pointer;">&times;</span>
        <h3>Set Update Interval</h3>
        <p>Enter a value between 0.5 and 10 seconds</p>
        <div style="margin: 20px 0;">
            <label for="interval-input">Interval (seconds):</label>
            <input type="range" id="interval-input" min="0.5" max="10" step="0.5" value="5" style="width: 100%;">
            <div style="text-align: center; margin-top: 10px;">
                <span id="interval-value">5.0</span> seconds
            </div>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <button id="cancel-interval" class="btn" style="background-color: #ccc;">Cancel</button>
            <button id="save-interval" class="btn">Save</button>
        </div>
        <div id="interval-status"></div>
    </div>
</div>

<!-- Add modal for graph refresh interval adjustment -->
<div id="graph-interval-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4);">
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; width: 400px; max-width: 90%; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
        <span id="close-graph-modal" style="position: absolute; top: 10px; right: 15px; font-size: 20px; cursor: pointer;">&times;</span>
        <h3>Set Graph Refresh Interval</h3>
        <p>How often should the graphs refresh? (1-30 seconds)</p>
        <div style="margin: 20px 0;">
            <label for="graph-interval-input">Refresh Interval (seconds):</label>
            <input type="range" id="graph-interval-input" min="1" max="30" step="1" value="5" style="width: 100%;">
            <div style="text-align: center; margin-top: 10px;">
                <span id="graph-interval-value">5</span> seconds
            </div>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <button id="cancel-graph-interval" class="btn" style="background-color: #ccc;">Cancel</button>
            <button id="save-graph-interval" class="btn">Save</button>
        </div>
        <div id="graph-interval-status"></div>
    </div>
</div>

</body>
</html>
